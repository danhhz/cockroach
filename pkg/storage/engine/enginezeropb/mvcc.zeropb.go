// Code generated by protoc-gen-zeropb. DO NOT EDIT.

package enginezeropb

import "github.com/danhhz/zeropb"

type MVCCMetadata struct {
	buf     []byte
	offsets struct {
		a [8]uint16
		m map[int]uint64
	}
}

var repeatedFields_MVCCMetadata = zeropb.RepeatedFields{}

func (m *MVCCMetadata) Encode() []byte {
	return m.buf
}

func (m *MVCCMetadata) Decode(buf []byte) error {
	m.buf = buf
	return zeropb.Decode(m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), repeatedFields_MVCCMetadata)
}

func (m *MVCCMetadata) Reset(buf []byte) {
	if len(buf) > 0 {
		panic(`buf must be empty`)
	}
	m.buf = buf
	zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m).Clear()
}

func (m *MVCCMetadata) Deleted() bool {
	return zeropb.GetBool(m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 3)
}

func (m *MVCCMetadata) SetDeleted(x bool) {
	zeropb.SetBool(&m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 3, x)
}

func (m *MVCCMetadata) KeyBytes() int64 {
	return zeropb.GetInt64(m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 4)
}

func (m *MVCCMetadata) SetKeyBytes(x int64) {
	zeropb.SetInt64(&m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 4, x)
}

func (m *MVCCMetadata) ValBytes() int64 {
	return zeropb.GetInt64(m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 5)
}

func (m *MVCCMetadata) SetValBytes(x int64) {
	zeropb.SetInt64(&m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 5, x)
}

func (m *MVCCMetadata) RawBytes() []byte {
	return zeropb.GetBytes(m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 6)
}

func (m *MVCCMetadata) SetRawBytes(x []byte) {
	zeropb.SetBytes(&m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 6, x)
}

func (m *MVCCMetadata) MergeTimestamp() []byte {
	return zeropb.GetBytes(m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 7)
}

func (m *MVCCMetadata) SetMergeTimestamp(x []byte) {
	zeropb.SetBytes(&m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 7, x)
}
